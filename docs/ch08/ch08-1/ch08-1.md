**1.动态规划和分治法有什么共同点？这两项汇总技术之间最主要的不同点是什么？**  
提示：请查看这两种方法的定义

解答：
a. 二者都要求原问题具有最优子结构性质,都是将原问题分而治之,分解成若干个规模较小(小到很容易解决的程序)的子问题.然后将子问题的解合并,形成原问题的解.

 分治法与动态规划实现方法不同:  
① 分治法通常利用递归求解.（例：归并排序，快速排序，快速傅里叶变换，一般用树结构）.    
② 动态规划通常通过状态转移方程利用迭代法自底向上求解,但也能用具有记忆功能的递归法自顶向下求解.  

b. 分治法与动态规划主要区别:  
① 分治法将分解后的子问题看成相互独立的，分治算法不像动态规划算法那样显式地将解存储到更小的实例中.  
② 动态规划将分解后的子问题理解为相互间有联系,有重叠部分，动态规划划分的子问题是有优先的.  



**2.求解币值最大化问题的一个实例5, 1, 2, 10, 6.**    
提示：运用8.1节中例1的方法，然后可以进行编程实现  

解答：  
F[0]=0, F[1]=c_{1}=5  
F[2]=max[c_{2}+F[0],F[1]]=max[1+0,5]=5  
F[3]=max[c_{3}+F[1],F[2]]=max[2+5,5]=7  
F[4]=max[c_{4}+F[2],F[3]]=max[10+5,7]=15  
F[5]=max[c_{5}+F[3],F[4]]=max[5+7,15]=15  
分析：现在回溯计算过程，最后一次应用递推方程，由F[4]给出了最大金额15，而在F[4]中最大金额15是由c_{4}+F[2]而来，这意味着c_{4}=10是最优解的一部分。继续回溯F[2]的计算  
	  其最大值有F[1]确定，意味着c_{1}是最优解的一部分。因此最优解是{c_{1},c_{4}}.  
	  
Python代码参考：
```python
def CoinRow(c):
    F = [0 for i in range(len(c) + 1)]  # F[n]表示n枚硬币的最大钱数
    F[0] = 0
    F[1] = c[0]
    for i in range(2, len(F)):
        F[i] = max(c[i - 1] + F[i - 2], F[i - 1])
        print(F[i])
    return F

if __name__== "__main__":
    c = [5, 1, 2, 10, 6]  # 数组c为保存n个硬币的面值
    y = CoinRow(c)
    print(y)
    print('最大的币值：', max(y))
```



**6.切割木棍问题**  
提示：类似于找零问题  

解答：  
长度为n的木棍共有2^n-1种不同的切割方案.如果一个最优解将木棍切割为k段（对某个1 ≤ k ≤ n)，那么最优切割方案n=i_{1}+i_{1}+...i_{k}    
将木棍切割为长度分别为i_{1},i_{1}...i_{k}的小段，得到最大收益profit(n)=p_{i_{1}}+p_{i_{1}}+...p_{i_{1}}   
为了求解规模为n的原问题，我们先求解形式完全一样，但规模更小的子问题.木棍切割问题满足最优子结构性质：问题的最优解由相关子问题的最优解组合而成，而这些子问题k可以独立求解.

假设最优的第一刀直接切出一个距离左端为i(i = 1, ....n-1)的木棍，这一段整体收益最大，即不再对这一段继续切割.只对剩余长度为n-i的木棍，
继续切割，求其收益最大的切割方案，这样问题只化为一个更小的子问题.用profit(n)表示最大收益.那么长度为n的递推公式为：
profit(n)=max(0<=i<=n)(p_{i}+profit(n-i))

```python
def cut_rod(p,n):
	#长度为0的木棍没有收益
	r = list()
	# let r[0] = 0
	r.append(0)
	for j in range(1,n+1):
		q = -sys.maxsize
		#求解规模为j的子问题解
		for i in range(1, j+1):
			q = max(q, p[i]+r[j-i])
		#将规模为j的子问题的解存入r[j]
		r.append(q)
	#返回最优解
	return r[n]
```
解决的主要思路是，先求解长度为1的最大收益，再到2,3.....一直到n，而每次求解的解都储存起来，时间复杂度为O(nm)，空间复杂度为O(n).



**7.最短路径数量**  
提示：C语言代码可参照https://blog.csdn.net/weixin_44614406/article/details/111601363  
a.将白车的最短路径数与棋盘第i行和第j列的正方形数与相邻正方形的最短路径数联系起来.  
b.假设一条最短路径是14步连续移动到相邻的方格.  

解答：  
a. 一般情况下，假设车最初位于棋盘的左下角，棋盘的行和列编号从1到8，  
设P(i, j)为车在第i行第j列从方格(1,1)到方格(i, j)的最短路径数，其中1≤i, j≤8.任何这样的路径都将由指向目标的垂直和水平移动组成.  
显然，对于任意1≤i, j≤8,P(i, 1) = P(1, j) = 1.一般来说，任何到方格(i, j)的最短路径都可以从方格(i, j−1)或者从方格(i−1,j)到达.  
因此，我们有下面的递归式  

p(i,j)=p(i,j-1)+p(i-1,j), 1<i,j<=8  
p(i,j-1)=p(i-1,j)=1,  1<=i,j<=8   

利用这个递归式，我们可以计算出棋盘上每个正方形(i.j)的P(i, j)的值.这可以逐行、逐列或逐对角线进行.  
(也可以利用棋盘的对称性，只计算棋盘主对角线上和上面或下面的方格.)结果如下表格所示：  
![image](https://github.com/datawhalechina/design-and-analysis-of-algorithm/blob/666d4c71426e6138f50b494aac4759226f9cdd85/docs/ch08/ch08-1/picture/T7.jpg)


b.从方格(1,1)到方格(8,8)的最短路径可以被认为是14个连续移动到相邻的方格，其中7个是向上的，而其他7个是向右的.例如，由从(1,1)到(8,1)的垂直移动和从(8,1)到(8,8)的水平移动组成的最短路径对应于以下14个一方格移动序列

(u, u, u, u, u, u, u, r, r, r, r, r, r, r)  

u和r分别代表向上和向右移动.因此，不同最短路径的总数等于从14个可能位置中选择7个u位置的不同方法的数量，等于C(14,7)=3432  






**12.世界大赛的胜率**   
提示：  
a.在A队和B队分别需要i场和j场比赛才能赢得系列赛的情况下，考虑A队赢得比赛的结果和A队输掉比赛的结果
b.建立一个5行(0≤i≤4)和5列(0≤j≤4)的表，并使用(a)部分导出的递归式填充该表.
c.伪代码应该以(A)部分中建立的递归式为指导.效率的答案直接来源于表的大小和计算每个条目所花费的时间


解答：
a.设Q(i, j)为A赢得系列赛的概率如果A需要i场比赛才能赢得系列赛而B需要j场比赛才能赢得系列赛.如果A队赢了比赛，概率是p，那么A队还需要i - 1场胜利才能赢得系列赛，
而B队仍然需要j场胜利.如果A队输了比赛，发生的概率是q = 1 - p，那么A队仍然需要i场胜利，
而B队需要j - 1场胜利才能赢得系列赛.这就导致了递归式

Q(i,j)=pQ(i-1,j)+qQ(i,j-1), i,j>0

初始条件直接由P(i, j)的定义得到:

Q(0,j)=1, j>0  
Q(i,0)=0, i>0  

b. 根据上面的分析，得到如下计算表格：  
![image](https://github.com/datawhalechina/design-and-analysis-of-algorithm/blob/666d4c71426e6138f50b494aac4759226f9cdd85/docs/ch08/ch08-1/picture/T12.jpg)  
此处所讨论的动态规划表，其中的条目四舍五入到小数点后两位.(它可以是逐行填充，或逐列填充，或逐对角线填充.)
表Q(4,4)约等于0.29

c.伪代码
```
//计算赢得一系列n场比赛的概率
//Input: 赢得这个系列赛需要很多胜利和某队获胜的概率p
//Output: 这支球队赢得系列赛的概率
q ← 1 − p
for j ← 1 to n do
	Q[0, j] ← 1.0
for i ← 1 to n do
	Q[i, 0] ← 0.0
	for j ← 1 to n do
		Q[i, j] ← p*Q[i − 1, j] + q*Q[i, j − 1]
return P[n, n]
```

时间效率和空间效率都在Θ(n^2)，因为n + 1 × n + 1表的每个条目(Q[0,0]除外，它没有计算)都在Θ(1)时间内计算。
