# 习题8.2  
*1. 提示：根据第二节中(8.6)和(8.7)式进行求解*  

解答：  
a.
|       | i |容量j    | 容量j|容量j    | 容量j |容量j    |容量j |容量j |
| -------- | ----- |----- |----- |----- |----- |----- |----- |----- |
|       | i |0    | 1|2    |3 |4    |5 |6|
|      | 0 |0     | 0 |0    | 0 |0     | 0 |6|
|w1 = 3, v1 = 25 | 1 |0   | 0 |0     | 25 |25     | 25 |25|
|w2 = 2, v2 = 20    | 2 |0     | 0 |20     |25 |25     | 45 |45|
| w3 = 1, v3 = 15     | 3 |0     | 15 |20     | 35 |40     | 45 |60|
| w4 = 4, v4 = 40     | 4 |0     | 15 |20     | 35 |40     | 55 |60|
|w5 = 5, v5 = 50     | 5 |0    | 15 |20     | 35 |40     | 55 |60|



可行子集的最大值V[5,6] = 65. 最优子集是{物品3，物品5}.  
b.a中实例只有一个最优解 
c.一个背包问题的实例有一个唯一的最优解，当且仅当用于获取最优子集的算法，即回溯V[n, W]的计算，在其运算过程中V[i−1,j]
和vi+ V[i−1,j−wi]之间不相等时，该实例有一个唯一的最优解.  


*2. 提示：根据第二节中(8.6)和(8.7)式进行伪代码编写，注意临界状态*  

解答：  
a.
```
DPKnapsack(w[1..n], v[1..n], W)
//通过动态规划(自底向上)解决背包问题
//Input: 数组 w[1..n] and v[1..n] 分别表示n个物品的重量和价值, 背包容量为W
//Output: 前i个物品的最优可行子集的价值
for i ← 0 to n do V[i, 0] ← 0
for j ← 1 to W do V[0, j] ← 0
for i ← 1 to n do
	for j ← 1 to W do
		if j − w[i] ≥ 0
			V[i, j] ← max{V[i − 1, j], v[i] + V[i − 1, j − w[i]]}
		else V[i, j] ← V[i − 1, j]
return V[n, W], V  
```
b.  
```
OptimalKnapsack(w[1...n], v[1...n], W)
//找到组成背包问题最优解的组成
//Input: 数组 w[1...n] and v[1...n] 分别表示n个物品的重量和价值, 背包容量为W，表V (0...n, 0...W)生成的
动态规划算法
//Output: 列表L [1...K]组成最优解的项
k ← 0 //最优解决方案中项目列表的大小
j ← W 
for i ← n downto 1 do
	if V[i, j] > V[i − 1, j]
		k ← k + 1; L[k] ← i //包含物品i
		j ← j − w[i]
return L
```

*3.提示：从算法计算了多少个值和需要遍历多少表单元格才能确定最佳子集的组成进行考虑*  

解答：  

a&b. 该算法用n + 1行和W + 1列填充一个表，花费Θ(1)时间填充一个单元格(通过应用(8.6)或(8.7). 因此，其时间效率和空间效率均在Θ(nW).  
c. 为了确定最优子集的组成，算法重复比较前一行中不超过两个单元格的值.因此，其时间效率等级为O(n).  


*5.提示：注意与本节的背包问题不同点在于，物品可以重复选择.*  

解答：  
此情况下背包问题与本节的背包问题(01背包)的区别在于每一件物品的数量都有无限个，而01背包每件物品数量只有一
问题解法其实和01背包问题一样，只是初始化的值和递推公式需要稍微变化一下.  
初始化时，当只考虑一件物品i时，f[1][j] = j/w[i]。递推公式计算时，f[i][j] = max{f[i-1][j], (f[i][j-w[i]]+v[i])}，注意这里当考虑放入一个物品 i 时应当考虑还可能继续放入 i，
因此这里是f[i][j-w[i]]+v[i], 而不是f[i-1][j-w[i]]+v[i].递推公式为：  

f[i][j] = max{f[i-1][j], (f[i][j-w[i]]+v[i])}

算法的时间效率θ(nW).  

代码可以参考：https://blog.csdn.net/u011956367/article/details/98475755?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-98475755-blog-89466282.pc_relevant_aa_2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-98475755-blog-89466282.pc_relevant_aa_2&utm_relevant_index=10




*8.提示：需要考虑其中一个原因与时间效率有关，另一个与空间效率有关*  

解答：  
对于计算二项式系数的问题，我们预先知道需要计算表中的哪些单元格.因此，自底向上动态规划算法还可以避免不必要的计算。此外，使用内存函数方法需要Θ(nk)空间，而自底向上算法只需要Θ(n)空间，原因是表的下一行可以写在它的上一行之上.  

